//! Contents provided to proc macros.
//!
//! Users should not use any content here.

use crate::{Reflect, info::TypePath, ops::ReflectCloneError};

pub mod alloc_utils {
    // When generating code, using `std` or `alloc` directly is unsafe.
    // Users may be in a `no_std` env or not displaying imported `alloc`.
    //
    // Therefore, proc-macro crate will use this path.
    pub use ::alloc::{
        borrow::{Cow, ToOwned},
        boxed::Box,
        string::ToString,
    };

    // Efficiently connect strings.
    #[inline(never)]
    pub fn concat(arr: &[&str]) -> alloc::string::String {
        let mut len = 0usize;
        for &item in arr {
            len += item.len();
        }
        let mut res = alloc::string::String::with_capacity(len);
        for &item in arr {
            res.push_str(item);
        }
        res
    }
}

pub fn reflect_clone_field<T: Reflect + TypePath>(source: &T) -> Result<T, ReflectCloneError> {
    if let Ok(t) = source.reflect_clone() 
        && let Ok(val) = t.take::<T>()
    {
        Ok(val)
    } else {
        Err(ReflectCloneError::NotImplemented {
            type_path: T::type_path().into()
        })
    }
}

// pub trait RegisterForReflection {
//     fn __register(_registry: &mut TypeRegistry) {}
// }

// impl<T: GetTypeTraits> RegisterForReflection for T {
//     fn __register(registry: &mut TypeRegistry) {
//         registry.register::<T>();
//     }
// }

// impl RegisterForReflection for DynamicEnum {}

// impl RegisterForReflection for DynamicTupleStruct {}

// impl RegisterForReflection for DynamicStruct {}

// impl RegisterForReflection for DynamicMap {}

// impl RegisterForReflection for DynamicSet {}

// impl RegisterForReflection for DynamicList {}

// impl RegisterForReflection for DynamicArray {}

// impl RegisterForReflection for DynamicTuple {}

#[cfg(feature = "auto_register")]
pub mod auto_register {
    use crate::registry::TypeRegistry;

    #[cfg(feature = "auto_register_inventory")]
    mod __auto_register_types_impl {
        use super::*;
        pub use inventory;

        pub struct AutoReflectRegisterFn(pub fn(&mut TypeRegistry));

        pub fn register_types(registry: &mut TypeRegistry) {
            #[cfg(target_family = "wasm")]
            wasm_support::init();
            for registry_fn in inventory::iter::<AutoReflectRegisterFn> {
                registry_fn.0(registry);
            }
        }

        inventory::collect!(AutoReflectRegisterFn);

        #[cfg(target_family = "wasm")]
        mod wasm_support {
            use vct_os::sync::atomic::{AtomicBool, Ordering};

            static INIT_DONE: AtomicBool = AtomicBool::new(false);

            #[expect(unsafe_code, reason = "This function is generated by linker.")]
            unsafe extern "C" {
                fn __wasm_call_ctors();
            }

            /// This function must be called before using [`inventory::iter`] on [`AutomaticReflectRegistrations`] to run constructors on all platforms.
            pub fn init() {
                if INIT_DONE.swap(true, Ordering::Relaxed) {
                    return;
                };
                // SAFETY:
                // This will call constructors on wasm platforms at most once (as long as `init` is the only function that calls `__wasm_call_ctors`).
                //
                // For more information see: https://docs.rs/inventory/latest/inventory/#webassembly-and-constructors
                #[expect(
                    unsafe_code,
                    reason = "This function must be called to use inventory on wasm."
                )]
                unsafe {
                    __wasm_call_ctors();
                }
            }
        }
    }

    /// static impl
    #[cfg(not(feature = "auto_register_inventory"))]
    mod __auto_register_types_impl {
        use super::*;
        use alloc::vec::Vec;
        use vct_os::sync::Mutex;

        static REGISTRATION_FNS: Mutex<Vec<fn(&mut TypeRegistry)>> = Mutex::new(Vec::new());

        /// Adds a new registration function for [`TypeRegistry`]
        pub fn push_registration_fn(registration_fn: fn(&mut TypeRegistry)) {
            REGISTRATION_FNS.lock().unwrap().push(registration_fn);
        }

        /// Registers all collected types.
        pub fn register_types(registry: &mut TypeRegistry) {
            for func in REGISTRATION_FNS.lock().unwrap().iter() {
                (func)(registry);
            }
        }
    }

    pub use __auto_register_types_impl::*;
}
