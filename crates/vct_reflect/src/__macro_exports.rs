use crate::{
    ops::{
        DynamicArray, DynamicEnum, DynamicList, DynamicMap, DynamicSet, DynamicStruct,
        DynamicTuple, DynamicTupleStruct,
    },
    registry::{GetTypeTraits, TypeRegistry},
};

pub mod alloc_utils {
    pub use ::alloc::{
        borrow::{Cow, ToOwned},
        boxed::Box,
        string::ToString,
    };
}

pub trait RegisterForReflection {
    #[expect(unused_variables)]
    fn __register(registry: &mut TypeRegistry) {}
}

impl<T: GetTypeTraits> RegisterForReflection for T {
    fn __register(registry: &mut TypeRegistry) {
        registry.register::<T>();
    }
}

impl RegisterForReflection for DynamicEnum {}

impl RegisterForReflection for DynamicTupleStruct {}

impl RegisterForReflection for DynamicStruct {}

impl RegisterForReflection for DynamicMap {}

impl RegisterForReflection for DynamicSet {}

impl RegisterForReflection for DynamicList {}

impl RegisterForReflection for DynamicArray {}

impl RegisterForReflection for DynamicTuple {}

#[cfg(feature = "auto_register")]
pub mod auto_register {
    pub use super::*;

    #[cfg(all(
        not(feature = "auto_register_inventory"),
        not(feature = "auto_register_static")
    ))]
    compile_error!(
        "Choosing a backend is required for automatic reflect registration. Please enable either the \"auto_register_inventory\" or the \"auto_register_static\" feature."
    );

    #[cfg(all(
        not(feature = "auto_register_static"),
        feature = "auto_register_inventory"
    ))]
    mod __auto_register_types_impl {
        use super::*;
        pub use inventory;

        pub struct AutoReflectRegisterFn(pub fn(&mut TypeRegistry));

        pub fn register_types(registry: &mut TypeRegistry) {
            #[cfg(target_family = "wasm")]
            wasm_support::init();
            for registry_fn in inventory::iter::<AutoReflectRegisterFn> {
                registry_fn.0(registry);
            }
        }

        inventory::collect!(AutoReflectRegisterFn);

        #[cfg(target_family = "wasm")]
        mod wasm_support {
            use vct_os::sync::atomic::{AtomicBool, Ordering};

            static INIT_DONE: AtomicBool = AtomicBool::new(false);

            #[expect(unsafe_code, reason = "This function is generated by linker.")]
            unsafe extern "C" {
                fn __wasm_call_ctors();
            }

            /// This function must be called before using [`inventory::iter`] on [`AutomaticReflectRegistrations`] to run constructors on all platforms.
            pub fn init() {
                if INIT_DONE.swap(true, Ordering::Relaxed) {
                    return;
                };
                // SAFETY:
                // This will call constructors on wasm platforms at most once (as long as `init` is the only function that calls `__wasm_call_ctors`).
                //
                // For more information see: https://docs.rs/inventory/latest/inventory/#webassembly-and-constructors
                #[expect(
                    unsafe_code,
                    reason = "This function must be called to use inventory on wasm."
                )]
                unsafe {
                    __wasm_call_ctors();
                }
            }
        }
    }

    /// static impl
    #[cfg(feature = "auto_register_static")]
    mod __auto_register_types_impl {
        use super::*;
        use alloc::vec::Vec;
        use vct_os::sync::Mutex;

        static REGISTRATION_FNS: Mutex<Vec<fn(&mut TypeRegistry)>> = Mutex::new(Vec::new());

        /// Adds a new registration function for [`TypeRegistry`]
        pub fn push_registration_fn(registration_fn: fn(&mut TypeRegistry)) {
            REGISTRATION_FNS.lock().unwrap().push(registration_fn);
        }

        /// Registers all collected types.
        pub fn register_types(registry: &mut TypeRegistry) {
            for func in REGISTRATION_FNS.lock().unwrap().iter() {
                (func)(registry);
            }
        }
    }

    #[cfg(any(feature = "auto_register_static", feature = "auto_register_inventory"))]
    pub use __auto_register_types_impl::*;
}
